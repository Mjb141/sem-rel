// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
	"go.opentelemetry.io/otel/trace"

	"dagger/sem-rel/internal/dagger"
	"dagger/sem-rel/internal/querybuilder"
	"dagger/sem-rel/internal/telemetry"
)

var dag = dagger.Connect()

func Tracer() trace.Tracer {
	return otel.Tracer("dagger.io/sdk.go")
}

// used for local MarshalJSON implementations
var marshalCtx = context.Background()

// called by main()
func setMarshalContext(ctx context.Context) {
	marshalCtx = ctx
	dagger.SetMarshalContext(ctx)
}

type DaggerObject = querybuilder.GraphQLMarshaller

type ExecError = dagger.ExecError

// ptr returns a pointer to the given value.
func ptr[T any](v T) *T {
	return &v
}

// convertSlice converts a slice of one type to a slice of another type using a
// converter function
func convertSlice[I any, O any](in []I, f func(I) O) []O {
	out := make([]O, len(in))
	for i, v := range in {
		out[i] = f(v)
	}
	return out
}

func (r SemRel) MarshalJSON() ([]byte, error) {
	var concrete struct{}
	return json.Marshal(&concrete)
}

func (r *SemRel) UnmarshalJSON(bs []byte) error {
	var concrete struct{}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	return nil
}

func (r Branch) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Name       string `json:"name"`
		Prerelease bool   `json:"prerelease"`
		Channel    string `json:"channel"`
	}
	concrete.Name = r.Name
	concrete.Prerelease = r.Prerelease
	concrete.Channel = r.Channel
	return json.Marshal(&concrete)
}

func (r *Branch) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Name       string `json:"name"`
		Prerelease bool   `json:"prerelease"`
		Channel    string `json:"channel"`
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Name = concrete.Name
	r.Prerelease = concrete.Prerelease
	r.Channel = concrete.Channel
	return nil
}

func main() {
	ctx := context.Background()

	// Direct slog to the new stderr. This is only for dev time debugging, and
	// runtime errors/warnings.
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slog.LevelWarn,
	})))

	if err := dispatch(ctx); err != nil {
		fmt.Println(err.Error())
		os.Exit(2)
	}
}

func dispatch(ctx context.Context) error {
	ctx = telemetry.InitEmbedded(ctx, resource.NewWithAttributes(
		semconv.SchemaURL,
		semconv.ServiceNameKey.String("dagger-go-sdk"),
		// TODO version?
	))
	defer telemetry.Close()

	// A lot of the "work" actually happens when we're marshalling the return
	// value, which entails getting object IDs, which happens in MarshalJSON,
	// which has no ctx argument, so we use this lovely global variable.
	setMarshalContext(ctx)

	fnCall := dag.CurrentFunctionCall()
	parentName, err := fnCall.ParentName(ctx)
	if err != nil {
		return fmt.Errorf("get parent name: %w", err)
	}
	fnName, err := fnCall.Name(ctx)
	if err != nil {
		return fmt.Errorf("get fn name: %w", err)
	}
	parentJson, err := fnCall.Parent(ctx)
	if err != nil {
		return fmt.Errorf("get fn parent: %w", err)
	}
	fnArgs, err := fnCall.InputArgs(ctx)
	if err != nil {
		return fmt.Errorf("get fn args: %w", err)
	}

	inputArgs := map[string][]byte{}
	for _, fnArg := range fnArgs {
		argName, err := fnArg.Name(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg name: %w", err)
		}
		argValue, err := fnArg.Value(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg value: %w", err)
		}
		inputArgs[argName] = []byte(argValue)
	}

	result, err := invoke(ctx, []byte(parentJson), parentName, fnName, inputArgs)
	if err != nil {
		return fmt.Errorf("invoke: %w", err)
	}
	resultBytes, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("marshal: %w", err)
	}
	if err = fnCall.ReturnValue(ctx, dagger.JSON(resultBytes)); err != nil {
		return fmt.Errorf("store return value: %w", err)
	}
	return nil
}
func invoke(ctx context.Context, parentJSON []byte, parentName string, fnName string, inputArgs map[string][]byte) (_ any, err error) {
	_ = inputArgs
	switch parentName {
	case "SemRel":
		switch fnName {
		case "AddBranchToReleaseRc":
			var parent SemRel
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var dir *dagger.Directory
			if inputArgs["dir"] != nil {
				err = json.Unmarshal([]byte(inputArgs["dir"]), &dir)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg dir", err))
				}
			}
			var branches []Branch
			if inputArgs["branches"] != nil {
				err = json.Unmarshal([]byte(inputArgs["branches"]), &branches)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg branches", err))
				}
			}
			return (*SemRel).AddBranchToReleaseRc(&parent, ctx, dir, branches)
		case "Release":
			var parent SemRel
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var releaserc *dagger.File
			if inputArgs["releaserc"] != nil {
				err = json.Unmarshal([]byte(inputArgs["releaserc"]), &releaserc)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg releaserc", err))
				}
			}
			var dir *dagger.Directory
			if inputArgs["dir"] != nil {
				err = json.Unmarshal([]byte(inputArgs["dir"]), &dir)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg dir", err))
				}
			}
			var provider string
			if inputArgs["provider"] != nil {
				err = json.Unmarshal([]byte(inputArgs["provider"]), &provider)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg provider", err))
				}
			}
			var addCurrentBranch bool
			if inputArgs["addCurrentBranch"] != nil {
				err = json.Unmarshal([]byte(inputArgs["addCurrentBranch"]), &addCurrentBranch)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg addCurrentBranch", err))
				}
			}
			var token *dagger.Secret
			if inputArgs["token"] != nil {
				err = json.Unmarshal([]byte(inputArgs["token"]), &token)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg token", err))
				}
			}
			return (*SemRel).Release(&parent, ctx, releaserc, dir, provider, addCurrentBranch, token)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "":
		return dag.Module().
			WithDescription("Configurable Semantic Release\n\nConfigurable Semantic Release module. Options are provided to modify your\nreleaserc file on demand for testing purposes (e.g. local/dry/no-ci runs,\nunlisted branches etc).\n\nUsable with Github or Gitlab with a PAT token.\n").
			WithObject(
				dag.TypeDef().WithObject("SemRel", dagger.TypeDefWithObjectOpts{SourceMap: dag.SourceMap("main.go", 21, 6)}).
					WithFunction(
						dag.Function("AddBranchToReleaseRc",
							dag.TypeDef().WithListOf(dag.TypeDef().WithObject("Branch"))).
							WithSourceMap(dag.SourceMap("main.go", 41, 1)).
							WithArg("dir", dag.TypeDef().WithObject("Directory"), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 41, 60)}).
							WithArg("branches", dag.TypeDef().WithListOf(dag.TypeDef().WithObject("Branch")), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 41, 83)})).
					WithFunction(
						dag.Function("Release",
							dag.TypeDef().WithObject("Container")).
							WithSourceMap(dag.SourceMap("main.go", 63, 1)).
							WithArg("releaserc", dag.TypeDef().WithObject("File").WithOptional(true), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 66, 2), DefaultPath: "/.releaserc.json"}).
							WithArg("dir", dag.TypeDef().WithObject("Directory").WithOptional(true), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 68, 2), DefaultPath: "/"}).
							WithArg("provider", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 70, 2), DefaultValue: dagger.JSON("\"Github\"")}).
							WithArg("addCurrentBranch", dag.TypeDef().WithKind(dagger.TypeDefKindBooleanKind), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 72, 2), DefaultValue: dagger.JSON("false")}).
							WithArg("token", dag.TypeDef().WithObject("Secret"), dagger.FunctionWithArgOpts{SourceMap: dag.SourceMap("main.go", 73, 2)}))).
			WithObject(
				dag.TypeDef().WithObject("Branch", dagger.TypeDefWithObjectOpts{SourceMap: dag.SourceMap("main.go", 23, 6)}).
					WithField("name", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.TypeDefWithFieldOpts{SourceMap: dag.SourceMap("main.go", 24, 2)}).
					WithField("prerelease", dag.TypeDef().WithKind(dagger.TypeDefKindBooleanKind), dagger.TypeDefWithFieldOpts{SourceMap: dag.SourceMap("main.go", 25, 2)}).
					WithField("channel", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.TypeDefWithFieldOpts{SourceMap: dag.SourceMap("main.go", 26, 2)})), nil
	default:
		return nil, fmt.Errorf("unknown object %s", parentName)
	}
}
